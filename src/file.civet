fs from fs
path from path
{ fileURLToPath } from url
* as convert from "./convert.civet"
type { Fold, Converter } from "./types.civet"

interface Options
  converter?: Converter
  flatFold?: boolean
  fold?: boolean
  unfold?: boolean

export function extensionOf(filename: string): string | null
  parsed := path.parse filename
  if parsed.ext
    parsed.ext
  else if parsed.base[0] == '.'
    parsed.base
  else if `.${filename}` in convert.extensions
    `.${filename}`
  else
    null

export function toFile(fold: Fold, output: string, converter?: Converter): void
  outFormat := extensionOf output
  unless outFormat
    console.warn `Could not detect extension of ${output}`
    return
  unless converter?
    converter = convert.getConverter '.fold', outFormat
    unless converter?
      console.warn `No converter from .fold to ${outFormat}`
      return

  result .= converter fold
  if typeof result != 'string'
    result = convert.toJSON result as Fold

  fs.writeFileSync output, result as string, 'utf-8'

export function fileToFile(input: string, output: string, options: Options): void
  inFormat := extensionOf input
  outFormat := extensionOf output
  unless inFormat
    console.warn `Could not detect extension of ${input}`
    return
  unless outFormat
    console.warn `Could not detect extension of ${output}`
    return
  converter .= options.converter
  unless converter?
    converter = convert.getConverter inFormat, outFormat
    unless converter?
      console.warn `No converter from ${inFormat} to ${outFormat}`
      return
  if outFormat == output or outFormat == `.${output}`
    // just extension => concatenate
    parsed_output := path.parse input
    parsed_output.ext = outFormat
    parsed_output.base = parsed_output.name + parsed_output.ext
    output = path.format parsed_output
  if input == output
    console.warn `Attempt to convert ${input} to same filename`
  else
    console.log input, '->', output
    result: unknown .= fs.readFileSync input, 'utf-8'
    if inFormat == '.fold' != outFormat // avoid double mogrification
      result = mogrify result as string, options
    result = converter result
    if outFormat == '.fold'
      result = mogrify result as string, options
    if typeof result != 'string'
      result = convert.toJSON result as Fold
    fs.writeFileSync output, result as string, 'utf-8'

export function mogrify(data: string, options: Options): string | undefined
  return unless options.flatFold // or any options set
  fold: Fold := JSON.parse data
  fold.file_creator = "fold-convert"
  if options.flatFold
    fold.file_creator += " --flat-fold"
    error := convert.flatFoldedGeometry fold
    console.log ` -- Flat folding error: ${error}`
    fold.vertices_flatUnfoldCoords = fold.vertices_coords
    fold.vertices_coords = fold.vertices_flatFoldCoords
    if fold.frame_classes?
      fold.frame_classes = fold.frame_classes.filter (x) => x != 'creasePattern'
      .concat 'foldedForm'
  if options.fold
    fold.file_creator += " --fold"
    error := convert.foldedGeometry fold
    console.log ` -- 3D folding error: ${error}`
    fold.vertices_unfoldCoords = fold.vertices_coords
    fold.vertices_coords = fold.vertices_foldCoords
    if fold.frame_classes?
      fold.frame_classes = fold.frame_classes.filter (x) => x != 'creasePattern'
      .concat 'foldedForm'
  if options.unfold
    fold.file_creator += " --unfold"
    error := convert.flatUnfoldedGeometry fold
    console.log ` -- Unfolding flat error: ${error}`
    fold.vertices_foldCoords = fold.vertices_coords
    fold.vertices_coords = fold.vertices_flatUnfoldCoords
    if fold.frame_classes?
      fold.frame_classes = fold.frame_classes.filter (x) -> x != 'foldedForm'
      .concat 'creasePattern'
  convert.toJSON fold

export function main(args = process.argv[2..]): void
  filenames := []
  output .= '.fold'  // Default behavior: convert to .fold
  options: Options := {}
  mode .= null

  for arg of args
    switch mode
      when 'output'
        output = arg
        mode = null
      else
        switch arg
          when '-o', '--output'
            mode = 'output'
          when '--flat-fold'
            options.flatFold = true
          when '--fold'
            options.fold = true
          when '--unfold'
            options.unfold = true
          else
            filenames.push arg

  for each filename of filenames
    fileToFile filename, output, options

main() if import.meta.url.startsWith('file:') and process.argv[1] == fileURLToPath(import.meta.url)
