* as geom from "./geom.civet"
type { Fold, Coords } from "./types.civet"

export function edgesAssigned(fold: Fold, target: string): number[]
  for assignment, i of fold.edges_assignment
    continue unless assignment == target
    i

export function mountainEdges(fold: Fold)
  edgesAssigned fold, 'M'

export function valleyEdges(fold: Fold)
  edgesAssigned fold, 'V'

export function flatEdges(fold: Fold)
  edgesAssigned fold, 'F'

export function boundaryEdges(fold: Fold)
  edgesAssigned fold, 'B'

export function unassignedEdges(fold: Fold)
  edgesAssigned fold, 'U'

export function cutEdges(fold: Fold)
  edgesAssigned fold, 'C'

export function joinEdges(fold: Fold)
  edgesAssigned fold, 'J'

export function keysStartingWith(fold: Fold, prefix: string)
  for key in fold
    continue unless key[...prefix.length] == prefix
    key

export function keysEndingWith(fold: Fold, suffix: string)
  for key in fold
    continue unless key[-suffix.length..] == suffix
    key

export function remapField(fold: Fold, field: string, old2new: number[])
  ###
  old2new: null means throw away that object
  ###
  new2old := []
  for each j, i of old2new  // later overwrites earlier
    new2old[j] = i if j?
  for key of keysStartingWith fold, `${field}_`
    fold[key] = (fold[key][old] for old of new2old)
  for key of keysEndingWith fold, `_${field}`
    fold[key] = ((old2new[old] for old of array) for array of fold[key])
  fold

export function remapFieldSubset(fold: Fold, field: string, keep: number[])
  id .= 0
  old2new :=
    for value of keep
      if value
        id++
      else
        null  // remove
  remapField fold, field, old2new
  old2new

export function remove(fold: Fold, field: string, index: number)
  ###
  Remove given index from given field ('vertices', 'edges', 'faces'), in place.
  ###
  remapFieldSubset fold, field,
    for i of [0...numType fold, field]
      i != index

export function removeVertex(fold: Fold, index: number)
  remove fold, 'vertices', index
export function removeEdge(fold: Fold, index: number)
  remove fold, 'edges', index
export function removeFace(fold: Fold, index: number)
  remove fold, 'faces', index

export function transform(fold: Fold, matrix: Coords[])
  ###
  Transforms all fields ending in _coords (in particular, vertices_coords)
  and all fields ending in FoldTransform (in particular,
  faces_flatFoldTransform generated by convert.flat_folded_geometry)
  according to the given transformation matrix.
  ###
  for key of keysEndingWith fold, "_coords"
    fold[key] = (geom.matrixVector(matrix, coords) for coords of fold[key])
  for key of keysEndingWith fold, "FoldTransform"
    continue unless '_' in key
    fold[key] = (geom.matrixMatrix(matrix, transform) for transform of fold[key])
  fold

export function numType(fold: Fold, type: string)
  ###
  Count the maximum number of objects of a given type, by looking at all
  fields with key of the form `type_...`, and if that fails, looking at all
  fields with key of the form `..._type`.  Returns `0` if nothing found.
  ###
  counts .=
    for key of keysStartingWith fold, `${type}_`
      value := fold[key]
      continue unless value.length?
      value.length
  unless counts.length
    counts =
      for key of keysEndingWith fold, `_${type}`
        1 + Math.max fold[key]...
  if counts.length
    Math.max counts...
  else
    0  // nothing of this type

export function numVertices(fold: Fold)
  numType fold, 'vertices'
export function numEdges(fold: Fold)
  numType fold, 'edges'
export function numFaces(fold: Fold)
  numType fold, 'faces'

export function removeDuplicateEdges_vertices(fold: Fold)
  seen: Record<string, number> := {}
  id .= 0
  old2new: number[] :=
    for edge of fold.edges_vertices
      [v, w] := edge
      key .= ""
      if v < w
        key = `${v},${w}`
      else
        key = `${w},${v}`
      unless key in seen
        seen[key] = id
        id += 1
      seen[key]
  remapField fold, 'edges', old2new
  old2new

export function edges_verticesIncident(e1: Coords, e2: Coords)
  for v of e1
    if v is in e2
      return v
  null

class RepeatedPointsDS
  hash: Record<string, number[]>
  epsilon: number
  vertices_coords:Coords[]

  @(@vertices_coords:Coords[], @epsilon: number)
    // Note: if vertices_coords has some duplicates in the initial state,
    // then we will detect them but won't remove them here.  Rather,
    // future duplicate inserts will return the higher-index vertex.
    @hash = {}
    for coord, v of @vertices_coords
      (@hash[@key coord] ?= []).push v
    null

  lookup(coord:Coords)
    [x, y] := coord
    xr := Math.round(x / @epsilon)
    yr := Math.round(y / @epsilon)
    for xt of [xr, xr-1, xr+1]
      for yt of [yr, yr-1, yr+1]
        key := `${xt},${yt}`
        for v of @hash[key] ?? []
          if @epsilon > geom.dist @vertices_coords[v], coord
            return v
    null

  key(coord:Coords)
    [x, y] := coord
    xr := Math.round x / @epsilon
    yr := Math.round y / @epsilon
    key := `${xr},${yr}`
    key

  insert(coord:Coords)
    v .= @lookup coord
    return v if v?
    (@hash[@key coord] ?= []).push v = @vertices_coords.length
    @vertices_coords.push coord
    v

export function collapseNearbyVertices(fold: Fold, epsilon: number)
  vertices := new RepeatedPointsDS [], epsilon
  old2new :=
    for coords of fold.vertices_coords
      vertices.insert coords
  remapField fold, 'vertices', old2new
  // In particular: fold.vertices_coords = vertices.vertices_coords

export function maybeAddVertex(fold: Fold, coords:Coords, epsilon: number)
  ###
  Add a new vertex at coordinates `coords` and return its (last) index,
  unless there is already such a vertex within distance `epsilon`,
  in which case return the closest such vertex's index.
  ###
  i := geom.closestIndex coords, fold.vertices_coords
  if i? and epsilon >= geom.dist coords, fold.vertices_coords[i]
    i  // Closest point is close enough
  else
    fold.vertices_coords.push(coords) - 1

export function addVertexLike(fold: Fold, oldVertexIndex: number)
  // Add a vertex and copy data from old vertex.
  vNew := numVertices fold
  for key of keysStartingWith fold, 'vertices_'
    switch key[6..]
      when 'vertices'
        // Leaving these broken
      else
        fold[key][vNew] = fold[key][oldVertexIndex]
  vNew

export function addEdgeLike(fold: Fold, oldEdgeIndex: number, v1?: number, v2?: number)
  // Add an edge between v1 and v2, and copy data from old edge.
  // If v1 or v2 are unspecified, defaults to the vertices of the old edge.
  // Must have `edges_vertices` property.
  eNew := fold.edges_vertices.length
  for key in keysStartingWith fold, 'edges_'
    switch key[6..]
      when 'vertices'
        fold.edges_vertices.push [
          v1 ?? fold.edges_vertices[oldEdgeIndex][0]
          v2 ?? fold.edges_vertices[oldEdgeIndex][1]
        ]
      when 'edges'
        // Leaving these broken
      else
        fold[key][eNew] = fold[key][oldEdgeIndex]
  eNew

export function addVertexAndSubdivide(fold: Fold, coords:Coords, epsilon: number)
  v := maybeAddVertex fold, coords, epsilon
  changedEdges: number[] := []
  if v == fold.vertices_coords.length - 1
    // Similar to "Handle overlapping edges" case:
    for e, i of fold.edges_vertices
      continue if v in e  // shouldn't happen
      s := (fold.vertices_coords[u] for u of e) as [Coords, Coords]
      if geom.pointStrictlyInSegment coords, s  // implicit epsilon
        // console.log coords, 'in', s
        iNew := addEdgeLike fold, i, v, e[1]
        changedEdges.push i, iNew
        e[1] = v
  [v, changedEdges] as const

export function removeLoopEdges(fold: Fold)
  ###
  Remove edges whose endpoints are identical.  After collapsing via
  `filter.collapseNearbyVertices`, this removes epsilon-length edges.
  ###
  remapFieldSubset fold, 'edges',
    for edge of fold.edges_vertices
      edge[0] != edge[1]

export function subdivideCrossingEdges_vertices(fold: Fold, epsilon: number): number[]
export function subdivideCrossingEdges_vertices(fold: Fold, epsilon: number, involvingEdgesFrom: number): [number[], number[]]
export function subdivideCrossingEdges_vertices(fold: Fold, epsilon: number, involvingEdgesFrom?: number)
  ###
  Using just `vertices_coords` and `edges_vertices` and assuming all in 2D,
  subdivides all crossing/touching edges to form a planar graph.
  In particular, all duplicate and loop edges are also removed.

  If called without `involvingEdgesFrom`, does all subdivision in quadratic
  time.  xxx Should be O(n log n) via plane sweep.
  In this case, returns an array of indices of all edges that were subdivided
  (both modified old edges and new edges).

  If called with `involvingEdgesFrom`, does all subdivision involving an
  edge numbered `involvingEdgesFrom` or higher.  For example, after adding an
  edge with largest number, call with `involvingEdgesFrom =
  edges_vertices.length - 1`; then this will run in linear time.
  In this case, returns two arrays of edges: the first array are all subdivided
  from the "involved" edges, while the second array is the remaining subdivided
  edges.
  ###

  changedEdges: [number[], number[]] := [[], []]
  addEdge := (v1: number, v2: number, oldEdgeIndex: number, which: number) ->
    // console.log 'adding', oldEdgeIndex, fold.edges_vertices.length, 'to', which
    eNew := addEdgeLike fold, oldEdgeIndex, v1, v2
    changedEdges[which].push oldEdgeIndex, eNew

  // Handle overlapping edges by subdividing edges at any vertices on them.
  // We use a while loop instead of a for loop to process newly added edges.
  i .= involvingEdgesFrom ?? 0
  while i < fold.edges_vertices.length
    e := fold.edges_vertices[i]
    s := (fold.vertices_coords[u] for u of e) as [Coords, Coords]
    for p, v of fold.vertices_coords
      continue if v is in e
      if geom.pointStrictlyInSegment p, s  // implicit epsilon
        // console.log p, 'in', s
        addEdge v, e[1], i, 0
        e[1] = v
    i++

  // Handle crossing edges
  // We use a while loop instead of a for loop to process newly added edges.
  vertices := new RepeatedPointsDS fold.vertices_coords, epsilon
  i1 .= involvingEdgesFrom ?? 0
  while i1 < fold.edges_vertices.length
    e1 := fold.edges_vertices[i1]
    s1 := (fold.vertices_coords[v] for v of e1) as [Coords, Coords]
    for e2, i2 of fold.edges_vertices[...i1]
      s2 := (fold.vertices_coords[v] for v of e2) as [Coords, Coords]
      if not edges_verticesIncident(e1, e2) and geom.segmentsCross s1, s2
        // segment intersection is too sensitive a test;
        // segmentsCross more reliable
        // cross = segmentIntersectSegment s1, s2
        cross := geom.lineIntersectLine s1, s2
        continue unless cross?
        crossI := vertices.insert cross as Coords
        // console.log e1, s1, 'intersects', e2, s2, 'at', cross, crossI
        unless crossI is in e1 and (crossI is in e2) // don't add endpoint again
          // console.log e1, e2, '->'
          unless crossI is in e1
            addEdge crossI, e1[1], i1, 0
            e1[1] = crossI
            s1[1] = fold.vertices_coords[crossI] // update for future iterations
            // console.log '->', e1, fold.edges_vertices[fold.edges_vertices.length-1]
          unless crossI is in e2
            addEdge crossI, e2[1], i2, 1
            e2[1] = crossI
            // console.log '->', e2, fold.edges_vertices[fold.edges_vertices.length-1]
    i1++

  old2new .= removeDuplicateEdges_vertices fold
  for i of [0, 1]
    changedEdges[i] = (old2new[e] for e of changedEdges[i])
  old2new = removeLoopEdges fold
  for i of [0, 1]
    changedEdges[i] = (old2new[e] for e of changedEdges[i])

  if involvingEdgesFrom?
    changedEdges
  else
    changedEdges[0].concat changedEdges[1]

// ------------------------- PORTED -----------------------------

export function addEdgeAndSubdivide(fold: Fold, v1Coord:Coords, v2Coord:Coords, epsilon: number)
  ###
  Add an edge between vertex indices or points `v1` and `v2`, subdivide
  as necessary, and return two arrays: all the subdivided parts of this edge,
  and all the other edges that change.
  If the edge is a loop or a duplicate, both arrays will be empty.
  ###
  changedEdges1: number[] .= []
  changedEdges2: number[] .= []
  v1: number | undefined .= undefined
  v2: number | undefined .= undefined

  if v1Coord.length?
    [v1, changedEdges1] = addVertexAndSubdivide fold, v1Coord, epsilon
  if v2Coord.length?
    [v2, changedEdges2] = addVertexAndSubdivide fold, v2Coord, epsilon
  if v1 == v2  // Ignore loop edges
    return [[], []]

  for e, i of fold.edges_vertices
    if (e[0] == v1 and e[1] == v2) or
       (e[0] == v2 and e[1] == v1)
      return [[i], []]  // Ignore duplicate edges

  iNew := fold.edges_vertices.push([v1, v2]) - 1
  changedEdges: [number[], number[]] .= [[],[]]

  if iNew
    changedEdges = subdivideCrossingEdges_vertices(fold, epsilon, iNew)
    changedEdges[0].push iNew unless iNew in changedEdges[0]
  else
    changedEdges = [[iNew], []]
  changedEdges[1].push changedEdges1... if changedEdges1?
  changedEdges[1].push changedEdges2... if changedEdges2?
  changedEdges

export function splitCuts(fold: Fold, es = cutEdges(fold))
  ###
  Given a FOLD object with `edges_vertices`, `edges_assignment`, and
  counterclockwise-sorted `vertices_edges`
  (see `FOLD.convert.edges_vertices_to_vertices_edges_sorted`),
  cuts apart ("unwelds") all edges in `es` into pairs of boundary edges.
  When an endpoint of a cut edge ends up on n boundaries,
  it splits into n vertices.
  Preserves above-mentioned properties (so you can then compute faces via
  `FOLD.convert.edges_vertices_to_faces_vertices_edges`),
  and recomputes `vertices_vertices` if present,
  but ignores face properties.
  `es` is unspecified, cuts all edges with an assignment of `"C"`,
  effectively switching from FOLD 1.2's `"C"` assignments to
  FOLD 1.1's `"B"` assignments.
  ###
  return fold unless es.length

  // Maintain map from every vertex to array of incident boundary edges
  vertices_boundaries: number[][] := []
  for e of boundaryEdges fold
    for v of fold.edges_vertices[e]
      (vertices_boundaries[v] ?= []).push e

  for e1 of es
    // Split e1 into two edges {e1, e2}
    e2 := addEdgeLike fold, e1
    for v, i of fold.edges_vertices[e1]
      ve := fold.vertices_edges[v]
      // Insert e2 before e1 in first vertex and after e1 in second vertex
      // to represent valid counterclockwise ordering
      ve.splice ve.indexOf(e1) + i, 0, e2

    // Check for endpoints of {e1, e2} to split, when they're on the boundary
    for v1 of fold.edges_vertices[e1]
      boundaries := vertices_boundaries[v1]?.length
      if boundaries >= 2  // vertex already on boundary
        if boundaries > 2
          throw new Error `${vertices_boundaries[v1].length} boundary edges at vertex ${v1}`
        [b1, b2] := vertices_boundaries[v1]
        neighbors .= fold.vertices_edges[v1]
        i1 := neighbors.indexOf b1
        i2 := neighbors.indexOf b2
        if i2 == (i1+1) % neighbors.length
          neighbors = neighbors[i2..].concat neighbors[..i1] unless i2 == 0
        else if i1 == (i2+1) % neighbors.length
          neighbors = neighbors[i1..].concat neighbors[..i2] unless i1 == 0
        else
          throw new Error `Nonadjacent boundary edges at vertex ${v1}`

        // Find first vertex among e1, e2 among neighbors, so other is next
        ie1 := neighbors.indexOf e1
        ie2 := neighbors.indexOf e2
        ie := Math.min ie1, ie2
        fold.vertices_edges[v1] = neighbors[..ie]
        v2 := addVertexLike fold, v1
        fold.vertices_edges[v2] = neighbors[1+ie..]
        // console.log "Split ${neighbors} into ${fold.vertices_edges[v1]} for ${v1} and ${fold.vertices_edges[v2]} for ${v2}"
        // Update relevant incident edges to use v2 instead of v1
        for neighbor of fold.vertices_edges[v2] // including e2
          ev := fold.edges_vertices[neighbor]
          ev[ev.indexOf v1] = v2
        // Partition boundary edges incident to v1
        vertices_boundaries[v1] = []
        vertices_boundaries[v2] = []
        for b of [b1, b2]
          if b in fold.vertices_edges[v1]
            vertices_boundaries[v1].push b
          else //if b in fold.vertices_edges[v2]
            vertices_boundaries[v2].push b

    // e1 and e2 are new boundary edges
    if fold.edges_assignment?
      fold.edges_assignment[e1] = 'B'
      fold.edges_assignment[e2] = 'B'

    for v of fold.edges_vertices[e1]
      (vertices_boundaries[v] ?= []).push e1
    for v of fold.edges_vertices[e2]
      (vertices_boundaries[v] ?= []).push e2

  if fold.vertices_vertices?  // would be out-of-date
    fold.vertices_vertices = edges_vertices_to_vertices_vertices fold
  fold

export function edges_vertices_to_vertices_vertices(fold: Fold)
  ###
  Works for abstract structures, so NOT SORTED.
  Use sort_vertices_vertices to sort in counterclockwise order.
  ###
  num_vertices := numVertices fold
  vertices_vertices: number[][] := ([] for v of [0...num_vertices])
  for [v, w] of fold.edges_vertices
    while v >= vertices_vertices.length
      vertices_vertices.push []
    while w >= vertices_vertices.length
      vertices_vertices.push []
    vertices_vertices[v].push w
    vertices_vertices[w].push v
  vertices_vertices

export function edges_vertices_to_vertices_edges(fold: Fold)
  ###
  Invert edges_vertices into vertices_edges.
  Works for abstract structures, so NOT SORTED in any sense.
  ###
  num_vertices := numVertices fold
  vertices_edges: number[][] := ([] for _ in [0...num_vertices])
  for vertices, edge of fold.edges_vertices
    for vertex of vertices
      vertices_edges[vertex].push edge
  vertices_edges
