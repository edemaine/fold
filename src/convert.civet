* as geom from "./geom.civet"
* as filter from "./filter.civet"
type { Coords, Fold, Converter } from "./types.civet"

/**
 * Works for abstract structures, so NOT SORTED.
 * Use sort_vertices_vertices to sort in counterclockwise order.
 */
export function edges_vertices_to_vertices_vertices_unsorted(fold: Fold): Fold
  fold.vertices_vertices = filter.edges_vertices_to_vertices_vertices fold
  fold

/**
 * Invert edges_vertices into vertices_edges.
 * Works for abstract structures, so NOT SORTED.
 */
export function edges_vertices_to_vertices_edges_unsorted(fold: Fold)
  fold.vertices_edges = filter.edges_vertices_to_vertices_edges fold
  fold

/**
 * Given a FOLD object with 2D `vertices_coords` and `edges_vertices` property
 * (defining edge endpoints), automatically computes the `vertices_vertices`
 * property and sorts them counterclockwise by angle in the plane.
 */
export function edges_vertices_to_vertices_vertices_sorted(fold: Fold): Fold
  edges_vertices_to_vertices_vertices_unsorted fold
  sort_vertices_vertices fold

/**
 * Given a FOLD object with 2D `vertices_coords` and `edges_vertices` property
 * (defining edge endpoints), automatically computes the `vertices_edges`
 * and `vertices_vertices` property and sorts them counterclockwise by angle
 * in the plane.
 */
export function edges_vertices_to_vertices_edges_sorted(fold: Fold): Fold
  edges_vertices_to_vertices_vertices_sorted fold
  vertices_vertices_to_vertices_edges fold

export function sort_vertices_vertices(fold: Fold): Fold
  ###
  Sorts `fold.vertices_vertices` in counterclockwise order using `fold.vertices_coords`.
  * 2D only.  Constructs `fold.vertices_vertices` if absent, via
  `convert.edges_vertices_to_vertices_vertices`.
  ###
  coords := fold.vertices_coords
  unless coords?
    throw new Error "sort_vertices_vertices: Vertex coordinates missing"
  unless coords.every .length == 2
    throw new Error "sort_vertices_vertices: Vertex coordinates not two dimensional"
  unless fold.vertices_vertices?
    edges_vertices_to_vertices_vertices_unsorted fold
    fold.vertices_vertices = fold.vertices_vertices!
  for v, neighbors in fold.vertices_vertices
    geom.sortByAngle neighbors, coords[v], (x: number) => coords[x]
  fold

export function vertices_vertices_to_faces_vertices(fold: Fold): Fold
  ###
  Given a 2D FOLD object with counterclockwise-sorted `vertices_vertices`
  property, constructs the implicitly defined faces, setting `faces_vertices`
  property.  Requires `vertices_coords` to exclude the outside face.
  ###
  unless fold.vertices_vertices?
    throw new Error "vertices_vertices_to_faces_vertices needs vertices_vertices"
  unless fold.vertices_coords?
    throw new Error "vertices_vertices_to_faces_vertices needs vertices_coords"
  next: Record<string, number | null> := {}
  for each neighbors, v of fold.vertices_vertices
    for each u, i of neighbors
      next[`${u},${v}`] = neighbors[(i-1) %% neighbors.length]

  fold.faces_vertices = []
  for each uv of Object.keys next
    w .= next[uv]
    continue unless w?
    next[uv] = null
    [uStr, vStr] := uv.split ','
    u .= parseInt uStr
    v .= parseInt vStr
    face := [u, v]
    until w == face[0]
      unless w?
        console.warn `Confusion with face ${face}`
        break
      face.push w
      [u, v] = [v, w]
      w = next[`${u},${v}`]
      next[`${u},${v}`] = null
    next[`${face[face.length-1]},${face[0]}`] = null
    // Outside face is clockwise; exclude it.
    if w? and geom.polygonOrientation((fold.vertices_coords[x] for each x of face)) > 0
      fold.faces_vertices.push face
  fold

/**
 * Given a FOLD object with counterclockwise-sorted `vertices_edges` property,
 * constructs the implicitly defined faces, setting both `faces_vertices`
 * and `faces_edges` properties.  Handles multiple edges to the same vertex
 * (unlike `FOLD.convert.vertices_vertices_to_faces_vertices`).
 * Requires `vertices_coords` to exclude the outside face.
 */
export function vertices_edges_to_faces_vertices_edges(fold: Fold): Fold
  unless fold.vertices_edges?
    throw new Error "vertices_edges_to_faces_vertices_edges needs vertices_edges"
  unless fold.edges_vertices?
    throw new Error "vertices_edges_to_faces_vertices_edges needs edges_vertices"
  unless fold.vertices_coords?
    throw new Error "vertices_edges_to_faces_vertices_edges needs vertices_coords"
  next: Record<number, number | null>[] := []
  for each neighbors, v of fold.vertices_edges
    next[v] = {}
    for each e, i of neighbors
      next[v][e] = neighbors[(i-1) %% neighbors.length]

  fold.faces_vertices = []
  fold.faces_edges = []

  for each nexts, vertex of next
    for e1Str, let e2 in nexts
      continue unless e2?
      e1 .= parseInt e1Str
      nexts[e1] = null
      edges := [e1]
      vertices: number[] := [
        filter.edges_verticesIncident fold.edges_vertices[e1],
                                      fold.edges_vertices[e2]
      ]
      unless vertices[0]?
        throw new Error `Confusion at edges ${e1} and ${e2}`
      until e2 == edges[0]
        unless e2?
          console.warn `Confusion with face containing edges ${edges}`
          break
        edges.push e2
        for each var v of fold.edges_vertices[e2]
          if v != vertices[vertices.length-1]
            vertices.push v
            break
        e1 = e2
        e2 = next[v][e1]
        next[v][e1] = null
      // Move e1 to the end so that edges[0] connects vertices[0] to vertices[1]
      edges.push edges.shift()!
      // Outside face is clockwise; exclude it.
      if e2? and geom.polygonOrientation((fold.vertices_coords[x] for each x of vertices)) > 0
        fold.faces_vertices.push vertices
        fold.faces_edges.push edges
  fold

/**
 * Given a FOLD object with 2D `vertices_coords` and `edges_vertices`,
 * computes a counterclockwise-sorted `vertices_vertices` property and
 * constructs the implicitly defined faces, setting `faces_vertices` property.
 */
export function edges_vertices_to_faces_vertices(fold: Fold): Fold
  edges_vertices_to_vertices_vertices_sorted fold
  vertices_vertices_to_faces_vertices fold

/**
 * Given a FOLD object with 2D `vertices_coords` and `edges_vertices`,
 * computes counterclockwise-sorted `vertices_vertices` and `vertices_edges`
 * properties and constructs the implicitly defined faces, setting
 * both `faces_vertices` and `faces_edges` property.
 */
export function edges_vertices_to_faces_vertices_edges(fold: Fold): Fold
  edges_vertices_to_vertices_edges_sorted fold
  vertices_edges_to_faces_vertices_edges fold

/**
 * Given a FOLD object with `vertices_vertices` and `edges_vertices`,
 * fills in the corresponding `vertices_edges` property (preserving order).
 */
export function vertices_vertices_to_vertices_edges(fold: Fold): Fold
  unless fold.vertices_vertices?
    throw new Error "vertices_vertices_to_vertices_edges needs vertices_vertices"
  unless fold.edges_vertices?
    throw new Error "vertices_vertices_to_vertices_edges needs edges_vertices"
  edgeMap: Record<string, number> := {}
  for each [v1, v2], edge of fold.edges_vertices
    edgeMap[`${v1},${v2}`] = edge
    edgeMap[`${v2},${v1}`] = edge
  fold.vertices_edges =
    for each vertices, vertex of fold.vertices_vertices
      for i of [0...vertices.length]
        edgeMap[`${vertex},${vertices[i]}`]
  fold

/**
 * Given a FOLD object with `faces_vertices` and `edges_vertices`,
 * fills in the corresponding `faces_edges` property (preserving order).
 */
export function faces_vertices_to_faces_edges(fold: Fold): Fold
  unless fold.faces_vertices?
    throw new Error "faces_vertices_to_faces_edges needs faces_vertices"
  unless fold.edges_vertices?
    throw new Error "faces_vertices_to_faces_edges needs edges_vertices"
  edgeMap: Record<string, number> := {}
  for each [v1, v2], edge of fold.edges_vertices
    edgeMap[`${v1},${v2}`] = edge
    edgeMap[`${v2},${v1}`] = edge
  fold.faces_edges =
    for each vertices, face of fold.faces_vertices
      for i of [0...vertices.length]
        edgeMap[`${vertices[i]},${vertices[(i+1) % vertices.length]}`]
  fold

/**
 * Given a FOLD object with just `faces_vertices`, automatically fills in
 * `edges_vertices`, `edges_faces`, `faces_edges`, and `edges_assignment`
 * (indicating which edges are boundary with 'B' and 'U').
 * This code currently assumes an orientable manifold, and uses nulls to
 * represent missing neighbor faces in `edges_faces` (for boundary edges).
 */
export function faces_vertices_to_edges(mesh: Fold): Fold
  unless mesh.faces_vertices?
    throw new Error "faces_vertices_to_edges needs faces_vertices"
  mesh.edges_vertices = []
  mesh.edges_faces = []
  mesh.faces_edges = []
  mesh.edges_assignment = []

  edgeMap: Record<string, number> := {}

  for faceStr, vertices in mesh.faces_vertices
    face := parseInt faceStr
    mesh.faces_edges.push(
      for each v1, i of vertices
        v2 := vertices[(i+1) % vertices.length]

        let key: string
        if v1 <= v2
          key = `${v1},${v2}`
        else
          key = `${v2},${v1}`

        let edge: number
        if key in edgeMap
          edge = edgeMap[key]
          // Second instance of edge means not on boundary
          mesh.edges_assignment[edge] = 'U'
        else
          edge = edgeMap[key] = mesh.edges_vertices.length
          if v1 <= v2
            mesh.edges_vertices.push [v1, v2]
          else
            mesh.edges_vertices.push [v2, v1]
          mesh.edges_faces.push [null, null]
          // First instance of edge might be on boundary
          mesh.edges_assignment.push 'B'

        if v1 <= v2
          mesh.edges_faces[edge][0] = face
        else
          mesh.edges_faces[edge][1] = face
        edge
    )
  mesh

export function edges_vertices_to_edges_faces_edges(fold: Fold): Fold
  ###
  Given a `fold` object with `edges_vertices` and `faces_vertices`,
  fills in `faces_edges` and `edges_faces`.
  ###
  unless fold.edges_vertices?
    throw new Error "edges_vertices_to_edges_faces_edges needs edges_vertices"
  unless fold.faces_vertices?
    throw new Error "edges_vertices_to_edges_faces_edges needs faces_vertices"
  fold.edges_faces = ([null, null] for edge of [0...fold.edges_vertices.length])
  edgeMap: Record<string, Coords> := {}

  for edgeStr, vertices in fold.edges_vertices
    continue unless vertices?
    edge := parseInt edgeStr
    edgeMap[`${vertices[0]},${vertices[1]}`] = [edge, 0] // forward
    edgeMap[`${vertices[1]},${vertices[0]}`] = [edge, 1] // backward

  fold.faces_edges ?= []
  for faceStr, vertices in fold.faces_vertices
    face := parseInt faceStr
    fold.faces_edges[face] =
      for each v1, i of vertices
        v2 := vertices[(i+1) % vertices.length]
        [edge, orient] := edgeMap[`${v1},${v2}`]
        fold.edges_faces[edge][orient] = face
        edge
  fold

export function computeFoldAngles(fold: Fold)
  unless fold.vertices_coords?
    throw new Error "computeFoldAngles needs vertices_coords"
  unless fold.edges_vertices?
    throw new Error "computeFoldAngles needs edges_vertices"
  unless fold.faces_vertices?
    throw new Error "computeFoldAngles needs faces_vertices"
  unless fold.edges_faces? and fold.faces_edges?
    edges_vertices_to_edges_faces_edges fold
    fold.faces_edges = fold.faces_edges! as number[][]
    fold.edges_faces = fold.edges_faces! as number[][]

  return fold.edges_foldAngle if fold.edges_foldAngle?

  foldAngles: number[] := []
  faceNormals: Coords[] := []

  for edge in fold.edges_vertices
    edgesFaces := (fold.edges_faces[edge].filter (x) => x?) as number[]

    // Not a boundary edge
    if edgesFaces.length == 2
      normals := for each face of edgesFaces
        faceCoords := for each vertex of fold.faces_vertices[face]
          fold.vertices_coords[vertex]

        faceNormals[face] ?= geom.polygonNormal(faceCoords)

      if normals[0] == null or normals[1] == null
        foldAngles[edge] = 0
      else
        toThree := (x: number[]) => Array.from({length: 3}, (_, i) => x[i] ?? 0)
        ang := geom.ang(toThree(normals[0]), toThree(normals[1]))!
        foldAngles[edge] = geom.toDegree(ang)
    else
      foldAngles[edge] = 0

  foldAngles

export function foldedGeometry(fold: Fold, rootFace = 0, edges_foldAngle = fold.edges_foldAngle): number
  unless fold.vertices_coords?
    throw new Error "foldedGeometry needs vertices_coords"
  unless fold.edges_vertices?
    throw new Error "foldedGeometry needs edges_vertices"
  unless edges_foldAngle?
    throw new Error "foldedGeometry needs edges_foldAngle"
  unless fold.edges_faces? and fold.faces_edges?
    edges_vertices_to_edges_faces_edges fold
    fold.faces_edges = fold.faces_edges! as number[][]
    fold.edges_faces = fold.edges_faces! as number[][]

  maxError .= 0
  level .= [rootFace]
  fold.faces_foldTransform = []
  fold.faces_foldTransform[rootFace] = [[1,0,0],[0,1,0],[0,0,1]]
  fold.vertices_foldCoords = Array(fold.vertices_coords.length).fill(null)

  // Use fold.faces_edges -> fold.edges_vertices, which are both needed below,
  // in case fold.faces_vertices isn't defined.
  for each edge of fold.faces_edges[rootFace]
    for each vertex of fold.edges_vertices[edge]
      fold.vertices_foldCoords[vertex] ?= fold.vertices_coords[vertex][..]

  while level.length
    nextLevel := []

    for each face of level
      for each edge of fold.faces_edges[face]
        for each face2 of fold.edges_faces[edge]
          continue unless face2? and face2 != face

          crease_edges_vertices := fold.edges_vertices[edge]
          crease_coords := (for each vertex of crease_edges_vertices
            fold.vertices_coords[vertex]
          ) as [Coords, Coords]

          transform := geom.matrixMatrix fold.faces_foldTransform[face]!, geom.matrixMatrix(
            geom.matrixMatrix(
              geom.matrixTranslate(crease_coords[1])
              geom.matrixRotate3D(...crease_coords, geom.toRadian(edges_foldAngle[edge]))
            ),
            geom.matrixTranslate(geom.mul crease_coords[1], -1)
          )

          if fold.faces_foldTransform[face2]?
            for each row, i of fold.faces_foldTransform[face2]!
              maxError = Math.max maxError, geom.dist row, transform[i]
          else
            fold.faces_foldTransform[face2] = transform

            for each edge2 of fold.faces_edges[face2]
              for each vertex2 of fold.edges_vertices[edge2]
                mapped := geom.matrixVector transform, fold.vertices_coords[vertex2]
                if coords := fold.vertices_foldCoords[vertex2]
                  maxError = Math.max maxError, geom.dist coords, mapped
                else
                  fold.vertices_foldCoords[vertex2] = mapped
            nextLevel.push face2
    level = nextLevel
  maxError

export function unfoldedGeometry(fold: Fold, rootFace = 0): number
  foldAngles := computeFoldAngles fold
  unfoldAngles := foldAngles.map (ang) => -ang
  foldedGeometry fold, rootFace, unfoldAngles

/**
 * Assuming `fold` is a locally flat foldable crease pattern in the xy plane,
 * sets `fold.vertices_flatFoldCoords` to give the flat-folded geometry
 * as determined by repeated reflection relative to `rootFace`; sets
 * `fold.faces_flatFoldTransform` transformation matrix mapping each face's
 * unfolded --> folded geometry; and sets `fold.faces_flatFoldOrientation` to
 * +1 or -1 to indicate whether each folded face matches its original
 * orientation or is upside-down (so is oriented clockwise in 2D).
 *
 * Requires `fold` to have `vertices_coords` and `edges_vertices`;
 * `edges_faces` and `faces_edges` will be created if they do not exist.
 *
 * Returns the maximum displacement error from closure constraints (multiple
 * mappings of the same vertices, or multiple transformations of the same face).
 */
export function flatFoldedGeometry(fold: Fold, rootFace = 0): number
  unless fold.vertices_coords?
    throw new Error "flatUnfoldedGeometry needs vertices_coords"
  unless fold.edges_vertices?
    throw new Error "flatUnfoldedGeometry needs edges_vertices"
  unless fold.edges_faces? and fold.faces_edges?
    edges_vertices_to_edges_faces_edges fold
    fold.faces_edges = fold.faces_edges! as number[][]
    fold.edges_faces = fold.edges_faces! as number[][]

  maxError .= 0
  level .= [rootFace]
  fold.faces_flatFoldTransform = Array(fold.faces_edges.length).fill(null)
  fold.faces_flatFoldTransform[rootFace] = [[1,0,0],[0,1,0]] // identity
  fold.faces_flatFoldOrientation = Array(fold.faces_edges.length).fill(null)
  fold.faces_flatFoldOrientation[rootFace] = +1
  fold.vertices_flatFoldCoords = Array(fold.vertices_coords.length).fill(null)

  // Use fold.faces_edges -> fold.edges_vertices, which are both needed below,
  // in case fold.faces_vertices isn't defined.
  for each edge of fold.faces_edges[rootFace]
    for each vertex of fold.edges_vertices[edge]
      fold.vertices_flatFoldCoords[vertex] ?= fold.vertices_coords[vertex][..]

  while level.length
    nextLevel := []

    for each face of level
      orientation := -fold.faces_flatFoldOrientation[face]!

      for each edge of fold.faces_edges[face]
        for each face2 of fold.edges_faces[edge]
          continue unless face2? and face2 != face
          transform := geom.matrixMatrix fold.faces_flatFoldTransform[face]!,
            geom.matrixReflectLine(...(
              for each vertex of fold.edges_vertices[edge]
                fold.vertices_coords[vertex]
            ) as [Coords, Coords])

          if fold.faces_flatFoldTransform[face2]?
            for each row, i of fold.faces_flatFoldTransform[face2]!
              maxError = Math.max maxError, geom.dist row, transform[i]
            if orientation != fold.faces_flatFoldOrientation[face2]
              maxError = Math.max 1, maxError
          else
            fold.faces_flatFoldTransform[face2] = transform
            fold.faces_flatFoldOrientation[face2] = orientation

            for each edge2 of fold.faces_edges[face2]
              for each vertex2 of fold.edges_vertices[edge2]
                mapped := geom.matrixVector transform, fold.vertices_coords[vertex2]
                if coords := fold.vertices_flatFoldCoords[vertex2]
                  maxError = Math.max maxError, geom.dist coords, mapped
                else
                  fold.vertices_flatFoldCoords[vertex2] = mapped
            nextLevel.push face2
    level = nextLevel
  maxError

// `foldedGeometry` is self-inverse
export function flatUnfoldedGeometry(fold: Fold, rootFace = 0): number
  flatFoldedGeometry fold, rootFace

export function deepCopy<T>(fold: T): T
  // Given a FOLD object, make a copy that shares no pointers with the original.
  if typeof fold is in ['number', 'string', 'boolean']
    fold
  else if Array.isArray fold
    (for each item of fold
      deepCopy item
    ) as T
  else // Object
    copy := {} as T
    for key, value in fold as object
      copy[key] = deepCopy value
    copy

/** Convert FOLD object into a nicely formatted JSON string. */
export function toJSON(fold: Fold): string
  "{\n" +
  (for key, value in fold
    `  ${JSON.stringify key}: ` +
    if Array.isArray value
      "[\n" +
      (`    ${JSON.stringify(obj)}` for each obj of value).join(',\n') +
      "\n  ]"
    else
      JSON.stringify value
  ).join(',\n') +
  "\n}\n"

export extensions: Record<string, boolean> := {}
export converters: Record<string, Converter> := {}

export function getConverter(fromExt: string, toExt: string): Converter | undefined
  if fromExt == toExt
    (x: any) => x
  else
    converters[`${fromExt}${toExt}`]

export function setConverter(fromExt: string, toExt: string, converter: Converter): void
  extensions[fromExt] = true
  extensions[toExt] = true
  converters[`${fromExt}${toExt}`] = converter

export function convertFromTo<T>(data: T, fromExt: string, toExt: string): unknown
  fromExt = `.${fromExt}` unless fromExt[0] == '.'
  toExt = `.${toExt}` unless toExt[0] == '.'
  converter := getConverter fromExt, toExt

  unless converter?
    throw new Error `No converter from ${fromExt} to ${toExt}`

  converter data

export function convertFrom<T>(data: T, fromExt: string): unknown
  convertFromTo data, fromExt, '.fold'

export function convertTo<T>(data: T, toExt: string): unknown
  convertFromTo data, '.fold', toExt

// export * as oripa from './oripa.civet'
